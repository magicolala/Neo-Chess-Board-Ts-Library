import type { Square, Arrow, SquareHighlight, HighlightType, DrawingState, Premove } from './types';
import { FILES, RANKS } from './utils';

export class DrawingManager {
  private state: DrawingState = {
    arrows: [],
    highlights: [],
    premove: undefined,
  };

  private canvas: HTMLCanvasElement;
  private squareSize: number = 60;
  private boardSize: number = 480;
  private orientation: 'white' | 'black' = 'white';
  private showSquareNames: boolean = false;

  /**
   * Tracks the current user interaction state
   */
  private currentAction: {
    type: 'none' | 'drawing_arrow';
    startSquare?: Square;
    shiftKey?: boolean;
    ctrlKey?: boolean;
    altKey?: boolean;
  } = { type: 'none' };

  // Couleurs par défaut pour les highlights
  private readonly HIGHLIGHT_COLORS = {
    green: 'rgba(34, 197, 94, 0.6)',
    red: 'rgba(239, 68, 68, 0.6)',
    blue: 'rgba(59, 130, 246, 0.6)',
    yellow: 'rgba(245, 158, 11, 0.6)',
    orange: 'rgba(249, 115, 22, 0.6)',
    purple: 'rgba(168, 85, 247, 0.6)',
  };

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.updateDimensions();
    this.currentAction = { type: 'none' };
  }

  public updateDimensions(): void {
    // Utiliser la vraie taille du canvas en pixels, pas la taille DOM
    this.boardSize = Math.min(this.canvas.width, this.canvas.height);
    this.squareSize = this.boardSize / 8;
  }

  public setOrientation(orientation: 'white' | 'black'): void {
    this.orientation = orientation;
  }

  public setShowSquareNames(show: boolean): void {
    this.showSquareNames = show;
  }

  // Gestion des flèches
  public addArrow(
    fromOrArrow:
      | Square
      | {
          from: Square;
          to: Square;
          color?: string;
          width?: number;
          opacity?: number;
          knightMove?: boolean;
        },
    to?: Square,
    color: string = 'rgba(34, 197, 94, 0.6)',
    width: number = 2,
  ): void {
    let arrow: {
      from: Square;
      to: Square;
      color: string;
      width: number;
      opacity: number;
      knightMove: boolean;
    };

    if (typeof fromOrArrow === 'object') {
      // Handle object parameter overload
      const arrowObj = fromOrArrow;
      arrow = {
        from: arrowObj.from,
        to: arrowObj.to,
        color: arrowObj.color || 'rgba(34, 197, 94, 0.6)',
        width: arrowObj.width || 2,
        opacity: arrowObj.opacity !== undefined ? arrowObj.opacity : 0.8,
        knightMove:
          arrowObj.knightMove !== undefined
            ? arrowObj.knightMove
            : this.isKnightMove(arrowObj.from, arrowObj.to),
      };
    } else {
      // Handle multiple parameters overload
      arrow = {
        from: fromOrArrow,
        to: to!,
        color,
        width: width || 2,
        opacity: 0.8,
        knightMove: this.isKnightMove(fromOrArrow, to!),
      };
    }

    const existingIndex = this.state.arrows.findIndex(
      (a) => a.from === arrow.from && a.to === arrow.to,
    );

    if (existingIndex >= 0) {
      // Update existing arrow
      this.state.arrows[existingIndex] = {
        ...this.state.arrows[existingIndex],
        ...arrow,
      };
    } else {
      // Add new arrow
      this.state.arrows.push(arrow);
    }
  }

  public removeArrow(from: Square, to: Square): void {
    this.state.arrows = this.state.arrows.filter(
      (arrow) => !(arrow.from === from && arrow.to === to),
    );
  }

  public clearArrows(): void {
    this.state.arrows = [];
  }

  public getArrows(): Arrow[] {
    return [...this.state.arrows];
  }

  // Gestion des highlights
  public addHighlight(
    square: Square,
    type: HighlightType | string = 'green',
    opacity?: number,
  ): void {
    // Determine opacity based on type if not provided
    const calculatedOpacity =
      opacity !== undefined ? opacity : type === 'selected' ? 0.5 : type === 'lastMove' ? 0.6 : 0.3;

    const existingIndex = this.state.highlights.findIndex((h) => h.square === square);

    if (existingIndex >= 0) {
      // Update existing highlight
      this.state.highlights[existingIndex] = {
        ...this.state.highlights[existingIndex],
        type: type as HighlightType,
        opacity: calculatedOpacity,
      };
    } else {
      // Add new highlight
      this.state.highlights.push({
        square,
        type: type as HighlightType,
        opacity: calculatedOpacity,
      });
    }
  }

  public removeHighlight(square: Square): void {
    this.state.highlights = this.state.highlights.filter((h) => h.square !== square);
  }

  public clearHighlights(): void {
    this.state.highlights = [];
  }

  /**
   * Get the pixel coordinates of the top-left corner of a square
   * @param square The square in algebraic notation (e.g., 'a1', 'h8')
   * @returns An object with x and y coordinates
   */
  private getSquareCoordinates(square: string): { x: number; y: number } {
    const file = square[0].toLowerCase();
    const rank = parseInt(square[1], 10);

    let fileIndex = file.charCodeAt(0) - 'a'.charCodeAt(0);
    let rankIndex = 8 - rank;

    // Adjust for board orientation
    if (this.orientation === 'black') {
      fileIndex = 7 - fileIndex;
      rankIndex = 7 - rankIndex;
    }

    return {
      x: fileIndex * this.squareSize,
      y: rankIndex * this.squareSize,
    };
  }

  /**
   * Get the size of a square in pixels
   */
  private getSquareSize(): number {
    return this.squareSize;
  }

  /**
   * Get the center point of a square in pixels
   */
  private getSquareCenter(square: string) {
    const { x, y } = this.getSquareCoordinates(square);
    const halfSize = this.squareSize / 2;
    return {
      x: x + halfSize,
      y: y + halfSize,
    };
  }

  public getHighlights(): SquareHighlight[] {
    return [...this.state.highlights];
  }

  // Gestion des premoves
  public setPremove(from: Square, to: Square, promotion?: 'q' | 'r' | 'b' | 'n'): void {
    this.state.premove = { from, to, promotion };
  }

  public clearPremove(): void {
    this.state.premove = undefined;
  }

  public getPremove(): Premove | undefined {
    return this.state.premove;
  }

  // Utilities pour les coordonnées
  public squareToCoords(square: Square): [number, number] {
    const file = square.charCodeAt(0) - 97; // 'a' = 0, 'b' = 1, etc.
    const rank = parseInt(square[1]) - 1; // '1' = 0, '2' = 1, etc.

    if (this.orientation === 'white') {
      return [file * this.squareSize, (7 - rank) * this.squareSize];
    } else {
      return [(7 - file) * this.squareSize, rank * this.squareSize];
    }
  }

  public coordsToSquare(x: number, y: number): Square {
    const file = Math.floor(x / this.squareSize);
    const rank = Math.floor(y / this.squareSize);

    let actualFile: number;
    let actualRank: number;

    if (this.orientation === 'white') {
      actualFile = file;
      actualRank = 7 - rank;
    } else {
      actualFile = 7 - file;
      actualRank = rank;
    }

    const fileChar = String.fromCharCode(97 + actualFile); // 0 = 'a', 1 = 'b', etc.
    const rankChar = (actualRank + 1).toString();

    return `${fileChar}${rankChar}` as Square;
  }

  // Détection des mouvements de cavalier
  private isKnightMove(from: Square, to: Square): boolean {
    const fromFile = from.charCodeAt(0) - 97; // 'a' = 0, 'b' = 1, etc.
    const fromRank = parseInt(from[1]) - 1; // '1' = 0, '2' = 1, etc.
    const toFile = to.charCodeAt(0) - 97;
    const toRank = parseInt(to[1]) - 1;

    const dx = Math.abs(toFile - fromFile);
    const dy = Math.abs(toRank - fromRank);

    // Un mouvement de cavalier est caractérisé par un mouvement de (1,2) ou (2,1)
    return (dx === 1 && dy === 2) || (dx === 2 && dy === 1);
  }

  // Rendu des flèches
  public renderSquareNames(orientation: 'white' | 'black', square: number, dpr: number = 1): void {
    const ctx = this.canvas.getContext('2d');
    if (!ctx) return;

    ctx.save();
    ctx.scale(dpr, dpr);

    const squareSize = this.squareSize / dpr;
    const fontSize = Math.max(10, squareSize * 0.18); // Taille de police légèrement réduite
    const filePadding = squareSize * 0.1;
    const rankPadding = squareSize * 0.15;

    // Style de police plus discret
    ctx.font = `500 ${fontSize}px 'Segoe UI', Arial, sans-serif`;
    ctx.textBaseline = 'middle';

    // Couleurs plus discrètes avec opacité
    const lightSquareColor = 'rgba(240, 217, 181, 0.7)';
    const darkSquareColor = 'rgba(181, 136, 99, 0.7)';

    // Dessiner les lettres de colonne (a-h)
    for (let file = 0; file < 8; file++) {
      const char = String.fromCharCode(97 + file); // a-h
      const x =
        file * squareSize + (orientation === 'white' ? filePadding : squareSize - filePadding);
      const y =
        orientation === 'white'
          ? this.canvas.height / dpr - filePadding
          : filePadding + fontSize / 2;

      // Utiliser la bonne couleur en fonction de l'orientation et de la case
      const isLightSquare = (file + (orientation === 'white' ? 7 : 0)) % 2 === 1;
      ctx.fillStyle = isLightSquare ? lightSquareColor : darkSquareColor;

      ctx.textAlign = orientation === 'white' ? 'left' : 'right';
      ctx.fillText(char, x, y);
    }

    // Dessiner les numéros de rangée (1-8)
    for (let rank = 0; rank < 8; rank++) {
      const num = orientation === 'white' ? 8 - rank : rank + 1;
      const x = orientation === 'white' ? rankPadding : this.canvas.width / dpr - rankPadding;
      const y =
        rank * squareSize +
        (orientation === 'white' ? squareSize - rankPadding : rankPadding + fontSize / 2);

      // Utiliser la bonne couleur en fonction de l'orientation et de la case
      const isLightSquare = (rank + (orientation === 'white' ? 1 : 0)) % 2 === 0;
      ctx.fillStyle = isLightSquare ? lightSquareColor : darkSquareColor;

      ctx.textAlign = orientation === 'white' ? 'left' : 'right';
      ctx.fillText(num.toString(), x, y);
    }

    ctx.restore();
  }

  public drawArrows(ctx: CanvasRenderingContext2D): void {
    ctx.save();

    for (const arrow of this.state.arrows) {
      this.drawArrow(ctx, arrow);
    }

    ctx.restore();
  }

  private drawArrow(ctx: CanvasRenderingContext2D, arrow: Arrow): void {
    if (arrow.knightMove) {
      this.drawKnightArrow(ctx, arrow);
    } else {
      this.drawStraightArrow(ctx, arrow);
    }
  }

  private drawStraightArrow(ctx: CanvasRenderingContext2D, arrow: Arrow): void {
    const [fromX, fromY] = this.squareToCoords(arrow.from);
    const [toX, toY] = this.squareToCoords(arrow.to);

    // Centrer les coordonnées sur les cases
    const centerFromX = fromX + this.squareSize / 2;
    const centerFromY = fromY + this.squareSize / 2;
    const centerToX = toX + this.squareSize / 2;
    const centerToY = toY + this.squareSize / 2;

    // Calculer l'angle et la distance
    const dx = centerToX - centerFromX;
    const dy = centerToY - centerFromY;
    const angle = Math.atan2(dy, dx);
    const length = Math.sqrt(dx * dx + dy * dy);

    // Ajuster les points de début et fin pour ne pas chevaucher les pièces
    const offset = this.squareSize * 0.25;
    const startX = centerFromX + Math.cos(angle) * offset;
    const startY = centerFromY + Math.sin(angle) * offset;
    const endX = centerToX - Math.cos(angle) * offset;
    const endY = centerToY - Math.sin(angle) * offset;

    // Configuration du style
    ctx.globalAlpha = arrow.opacity || 0.8;
    ctx.strokeStyle = arrow.color;
    ctx.fillStyle = arrow.color;
    ctx.lineWidth = arrow.width || 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Dessiner la ligne
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // Dessiner la pointe de la flèche
    const arrowHeadSize = (arrow.width || 4) * 3;
    const arrowAngle = Math.PI / 6; // 30 degrés

    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(
      endX - arrowHeadSize * Math.cos(angle - arrowAngle),
      endY - arrowHeadSize * Math.sin(angle - arrowAngle),
    );
    ctx.lineTo(
      endX - arrowHeadSize * Math.cos(angle + arrowAngle),
      endY - arrowHeadSize * Math.sin(angle + arrowAngle),
    );
    ctx.closePath();
    ctx.fill();
  }

  private drawKnightArrow(ctx: CanvasRenderingContext2D, arrow: Arrow): void {
    const [fromX, fromY] = this.squareToCoords(arrow.from);
    const [toX, toY] = this.squareToCoords(arrow.to);

    // Centrer les coordonnées sur les cases
    const centerFromX = fromX + this.squareSize / 2;
    const centerFromY = fromY + this.squareSize / 2;
    const centerToX = toX + this.squareSize / 2;
    const centerToY = toY + this.squareSize / 2;

    // Calculer le mouvement du cavalier
    const dx = centerToX - centerFromX;
    const dy = centerToY - centerFromY;

    // Déterminer l'orientation du L (horizontal puis vertical ou vertical puis horizontal)
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);

    let cornerX: number, cornerY: number;

    // Si le mouvement horizontal est plus grand, on va d'abord horizontalement
    if (absDx > absDy) {
      cornerX = centerToX;
      cornerY = centerFromY;
    } else {
      // Sinon, on va d'abord verticalement
      cornerX = centerFromX;
      cornerY = centerToY;
    }

    // Configuration du style
    ctx.globalAlpha = arrow.opacity || 0.8;
    ctx.strokeStyle = arrow.color;
    ctx.fillStyle = arrow.color;
    ctx.lineWidth = arrow.width || 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Ajustement pour éviter le chevauchement avec les pièces
    const offset = this.squareSize * 0.2;

    // Calculer les points de départ et d'arrivée ajustés
    let startX = centerFromX;
    let startY = centerFromY;
    let endX = centerToX;
    let endY = centerToY;

    // Ajuster le point de départ
    if (absDx > absDy) {
      // Premier segment horizontal
      startX += dx > 0 ? offset : -offset;
      endX += dx > 0 ? -offset : offset;
    } else {
      // Premier segment vertical
      startY += dy > 0 ? offset : -offset;
      endY += dy > 0 ? -offset : offset;
    }

    // Dessiner le L avec deux segments
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(cornerX, cornerY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // Dessiner la pointe de la flèche à la fin
    const arrowHeadSize = (arrow.width || 4) * 3;
    const arrowAngle = Math.PI / 6; // 30 degrés

    // Calculer l'angle du dernier segment
    let finalAngle: number;
    if (absDx > absDy) {
      // Le dernier segment est vertical
      finalAngle = dy > 0 ? Math.PI / 2 : -Math.PI / 2;
    } else {
      // Le dernier segment est horizontal
      finalAngle = dx > 0 ? 0 : Math.PI;
    }

    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(
      endX - arrowHeadSize * Math.cos(finalAngle - arrowAngle),
      endY - arrowHeadSize * Math.sin(finalAngle - arrowAngle),
    );
    ctx.lineTo(
      endX - arrowHeadSize * Math.cos(finalAngle + arrowAngle),
      endY - arrowHeadSize * Math.sin(finalAngle + arrowAngle),
    );
    ctx.closePath();
    ctx.fill();
  }

  // Rendu des highlights
  public drawHighlights(ctx: CanvasRenderingContext2D): void {
    ctx.save();

    for (const highlight of this.state.highlights) {
      this.drawHighlight(ctx, highlight);
    }

    ctx.restore();
  }

  private drawHighlight(ctx: CanvasRenderingContext2D, highlight: SquareHighlight): void {
    const [x, y] = this.squareToCoords(highlight.square);

    let color: string;
    if (highlight.type === 'circle') {
      // PGN annotations provide the color directly.
      // Default to a color if not provided, although it should be.
      color = highlight.color || 'rgba(255, 255, 0, 0.5)';
    } else {
      // Other highlights get their color from the type.
      color = this.HIGHLIGHT_COLORS[highlight.type as keyof typeof this.HIGHLIGHT_COLORS];
    }

    ctx.globalAlpha = highlight.opacity || 0.6;
    ctx.fillStyle = color;

    // Dessiner un cercle au centre de la case
    const centerX = x + this.squareSize / 2;
    const centerY = y + this.squareSize / 2;
    const radius = this.squareSize * 0.15;

    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
    ctx.fill();

    // Ajouter un contour
    ctx.globalAlpha = (highlight.opacity || 0.6) * 1.5;
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  // Rendu du premove
  public drawPremove(ctx: CanvasRenderingContext2D): void {
    if (!this.state.premove) return;

    ctx.save();

    const [fromX, fromY] = this.squareToCoords(this.state.premove.from);
    const [toX, toY] = this.squareToCoords(this.state.premove.to);

    // Style du premove (flèche en pointillés)
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = '#ff9800';
    ctx.lineWidth = 3;
    // Utiliser setLineDash seulement si disponible (test environnements)
    if (ctx.setLineDash) {
      ctx.setLineDash([8, 4]);
    }
    ctx.lineCap = 'round';

    const centerFromX = fromX + this.squareSize / 2;
    const centerFromY = fromY + this.squareSize / 2;
    const centerToX = toX + this.squareSize / 2;
    const centerToY = toY + this.squareSize / 2;

    // Dessiner la ligne en pointillés
    ctx.beginPath();
    ctx.moveTo(centerFromX, centerFromY);
    ctx.lineTo(centerToX, centerToY);
    ctx.stroke();

    // Dessiner les cases de départ et d'arrivée
    if (ctx.setLineDash) {
      ctx.setLineDash([]);
    }
    ctx.fillStyle = 'rgba(255, 152, 0, 0.3)';

    // Case de départ
    ctx.fillRect(fromX, fromY, this.squareSize, this.squareSize);

    // Case d'arrivée
    ctx.fillRect(toX, toY, this.squareSize, this.squareSize);

    ctx.restore();
  }

  // Méthodes pour obtenir l'état complet
  public getDrawingState(): DrawingState {
    return {
      arrows: [...this.state.arrows],
      highlights: [...this.state.highlights],
      premove: this.state.premove ? { ...this.state.premove } : undefined,
    };
  }

  public setDrawingState(state: Partial<DrawingState>): void {
    if (state.arrows !== undefined) {
      this.state.arrows = [...state.arrows];
    }
    if (state.highlights !== undefined) {
      this.state.highlights = [...state.highlights];
    }
    if (state.premove !== undefined) {
      this.state.premove = state.premove ? { ...state.premove } : undefined;
    }
  }

  public clearAllDrawings(): void {
    this.state = {
      arrows: [],
      highlights: [],
      premove: undefined,
    };
  }

  // Utilitaires pour les interactions
  public getSquareFromMousePosition(mouseX: number, mouseY: number): Square | null {
    const rect = this.canvas.getBoundingClientRect();
    const x = (mouseX - rect.left) * (this.canvas.width / rect.width);
    const y = (mouseY - rect.top) * (this.canvas.height / rect.height);

    if (x < 0 || y < 0 || x >= this.canvas.width || y >= this.canvas.height) {
      return null;
    }

    return this.coordsToSquare(x, y);
  }

  // Cycle des couleurs de highlight au clic droit
  public cycleHighlight(square: Square): void {
    const existingIndex = this.state.highlights.findIndex((h) => h.square === square);

    if (existingIndex >= 0) {
      const currentType = this.state.highlights[existingIndex].type;
      const types: HighlightType[] = ['green', 'red', 'blue', 'yellow', 'orange', 'purple'];
      const currentTypeIndex = types.indexOf(currentType);
      const nextTypeIndex = (currentTypeIndex + 1) % types.length;

      if (nextTypeIndex === 0) {
        // Si on revient au vert après un cycle complet, supprimer le highlight
        this.removeHighlight(square);
      } else {
        this.state.highlights[existingIndex].type = types[nextTypeIndex];
      }
    } else {
      // Ajouter un nouveau highlight vert
      this.addHighlight(square, 'green');
    }
    if (state.highlights !== undefined) {
      this.state.highlights = [...state.highlights];
    }
    if (state.premove !== undefined) {
      this.state.premove = state.premove ? { ...state.premove } : undefined;
    }
  }

  public clearAllDrawings(): void {
    this.state = {
      arrows: [],
      highlights: [],
      premove: undefined,
    };
  }

  // Utilitaires pour les interactions
  public getSquareFromMousePosition(mouseX: number, mouseY: number): Square | null {
    const rect = this.canvas.getBoundingClientRect();
    const x = (mouseX - rect.left) * (this.canvas.width / rect.width);
    const y = (mouseY - rect.top) * (this.canvas.height / rect.height);

    if (x < 0 || y < 0 || x >= this.canvas.width || y >= this.canvas.height) {
      return null;
    }

    return this.coordsToSquare(x, y);
  }

  // Cycle des couleurs de highlight au clic droit
  public cycleHighlight(square: Square): void {
    const existingIndex = this.state.highlights.findIndex((h) => h.square === square);

    if (existingIndex >= 0) {
      const currentType = this.state.highlights[existingIndex].type;
      const types: HighlightType[] = ['green', 'red', 'blue', 'yellow', 'orange', 'purple'];
      const currentTypeIndex = types.indexOf(currentType);
      const nextTypeIndex = (currentTypeIndex + 1) % types.length;

      if (nextTypeIndex === 0) {
        // Si on revient au vert après un cycle complet, supprimer le highlight
        this.removeHighlight(square);
      } else {
        this.state.highlights[existingIndex].type = types[nextTypeIndex];
      }
    } else {
      // Ajouter un nouveau highlight vert
      this.addHighlight(square, 'green');
    }
  }

  // Rendu complet de tous les éléments
  public draw(ctx: CanvasRenderingContext2D): void {
    // L'ordre est important pour la superposition correcte
    this.drawHighlights(ctx);
    this.drawPremove(ctx);
    this.drawArrows(ctx);
    if (this.showSquareNames) {
      this._drawSquareNames(ctx);
    }
  }

  // Vérifier si un point est près d'une flèche (pour suppression)
  public getArrowAt(mouseX: number, mouseY: number, tolerance: number = 10): Arrow | null {
    const rect = this.canvas.getBoundingClientRect();
    const x = mouseX - rect.left;
    const y = mouseY - rect.top;

    for (const arrow of this.state.arrows) {
      if (this.isPointNearArrow(x, y, arrow, tolerance)) {
        return arrow;
      }
    }

    return null;
  }

  private isPointNearArrow(x: number, y: number, arrow: Arrow, tolerance: number): boolean {
    const [fromX, fromY] = this.squareToCoords(arrow.from);
    const [toX, toY] = this.squareToCoords(arrow.to);

    const centerFromX = fromX + this.squareSize / 2;
    const centerFromY = fromY + this.squareSize / 2;
    const centerToX = toX + this.squareSize / 2;
    const centerToY = toY + this.squareSize / 2;

    // Calculer la distance du point à la ligne
    const lineLength = Math.sqrt(
      Math.pow(centerToX - centerFromX, 2) + Math.pow(centerToY - centerFromY, 2),
    );

    if (lineLength === 0) return false;

    const distance = Math.abs(
      ((centerToY - centerFromY) * x -
        (centerToX - centerFromX) * y +
        centerToX * centerFromY -
        centerToY * centerFromX) /
        lineLength,
    );

    return distance <= tolerance;
  }

  // Export/Import pour la persistance
  public exportState(): string {
    return JSON.stringify(this.state);
  }

  public importState(stateJson: string): void {
    try {
      const imported = JSON.parse(stateJson);
      this.setDrawingState(imported);
    } catch (error) {
      console.warn('Failed to import drawing state:', error);
    }
  }

  // Méthodes d'interaction pour NeoChessBoard
  private currentAction: {
    type: 'none' | 'drawing_arrow';
    startSquare?: Square;
    shiftKey?: boolean;
    ctrlKey?: boolean;
    altKey?: boolean;
  } = { type: 'none' };

  public handleMouseDown(x: number, y: number, shiftKey: boolean, ctrlKey: boolean): boolean {
    // Ne pas gérer le clic gauche ici, les flèches se font maintenant au clic droit
    return false;
  }

  public handleRightMouseDown(
    x: number,
    y: number,
    shiftKey: boolean = false,
    ctrlKey: boolean = false,
    altKey: boolean = false,
  ): boolean {
    const square = this.coordsToSquare(x, y);

    // Commencer à dessiner une flèche au clic droit avec les modificateurs
    this.currentAction = { type: 'drawing_arrow', startSquare: square, shiftKey, ctrlKey, altKey };
    return true;
  }

  public handleMouseMove(x: number, y: number): boolean {
    // Pour l'instant, ne rien faire pendant le mouvement
    return false;
  }

  public handleMouseUp(x: number, y: number): boolean {
    // Cette méthode n'est plus utilisée pour les flèches (clic droit)
    this.currentAction = { type: 'none' };
    return false;
  }

  public handleRightMouseUp(x: number, y: number): boolean {
    if (this.currentAction.type === 'drawing_arrow' && this.currentAction.startSquare) {
      const endSquare = this.coordsToSquare(x, y);
      if (endSquare !== this.currentAction.startSquare) {
        // Déterminer la couleur selon les modificateurs
        let color = '#ffeb3b'; // jaune par défaut
        if (this.currentAction.shiftKey) {
          color = '#22c55e'; // vert
        } else if (this.currentAction.ctrlKey) {
          color = '#ef4444'; // rouge
        } else if (this.currentAction.altKey) {
          color = '#f59e0b'; // orange/jaune
        }

        // Vérifier s'il existe déjà une flèche identique (même from, to, et couleur)
        const existingArrow = this.state.arrows.find(
          (arrow) =>
            arrow.from === this.currentAction.startSquare &&
            arrow.to === endSquare &&
            arrow.color === color,
        );

        if (existingArrow) {
          // Supprimer la flèche identique
          this.removeArrow(this.currentAction.startSquare, endSquare);
        } else {
          // Ajouter ou remplacer la flèche avec la nouvelle couleur
          this.addArrow(this.currentAction.startSquare, endSquare, color);
        }

        this.currentAction = { type: 'none' };
        return true;
      }
    }

    this.currentAction = { type: 'none' };
    return false;
  }

  public handleHighlightClick(
    square: Square,
    shiftKey: boolean = false,
    ctrlKey: boolean = false,
    altKey: boolean = false,
  ): void {
    if (shiftKey || ctrlKey || altKey) {
      // Avec modificateurs, appliquer directement la couleur correspondante
      let highlightType: HighlightType = 'green';
      if (shiftKey) {
        highlightType = 'green';
      } else if (ctrlKey) {
        highlightType = 'red';
      } else if (altKey) {
        highlightType = 'yellow';
      }

      // Si un highlight existe déjà avec la même couleur, le supprimer
      const existing = this.state.highlights.find(
        (h) => h.square === square && h.type === highlightType,
      );
      if (existing) {
        this.removeHighlight(square);
      } else {
        this.addHighlight(square, highlightType);
      }
    } else {
      // Sans modificateurs, conserver le comportement de cycle existant
      this.cycleHighlight(square);
    }
  }

  public renderPremove(): void {
    const ctx = this.canvas.getContext('2d');
    if (ctx) {
      this.drawPremove(ctx);
    }
  }

  public renderHighlights(): void {
    const ctx = this.canvas.getContext('2d');
    if (ctx) {
      this.drawHighlights(ctx);
    }
  }

  // Méthodes avec signatures adaptées pour NeoChessBoard
  public addArrowFromObject(arrow: Arrow): void {
    this.addArrow(arrow.from, arrow.to, arrow.color, arrow.width);
  }

  public addHighlightFromObject(highlight: SquareHighlight): void {
    this.addHighlight(highlight.square, highlight.type, highlight.opacity);
  }

  public setPremoveFromObject(premove: Premove): void {
    this.setPremove(premove.from, premove.to, premove.promotion);
  }

  // Alias pour compatibilité
  public clearAll(): void {
    this.clearAllDrawings();
  }

  private _drawSquareNames(ctx: CanvasRenderingContext2D): void {
    ctx.save();
    ctx.font = `${Math.floor(this.squareSize * 0.18)}px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto`;
    ctx.textBaseline = 'bottom';
    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(0,0,0,0.35)';

    for (let r = 0; r < 8; r++) {
      for (let f = 0; f < 8; f++) {
        const square = this.coordsToSquare(f * this.squareSize, r * this.squareSize);
        const [x, y] = this.squareToCoords(square);

        // Draw file names (a, b, c...) on the bottom rank
        if (r === (this.orientation === 'white' ? 7 : 0)) {
          const file = this.orientation === 'white' ? FILES[f] : FILES[7 - f];
          ctx.fillText(
            file,
            x + this.squareSize * 0.06,
            y + this.squareSize - this.squareSize * 0.06,
          );
        }

        // Draw rank names (1, 2, 3...) on the left file
        if (f === (this.orientation === 'white' ? 0 : 7)) {
          const rank = this.orientation === 'white' ? RANKS[7 - r] : RANKS[r];
          ctx.fillText(
            rank,
            x + this.squareSize * 0.06,
            y + this.squareSize * 0.06 + Math.floor(this.squareSize * 0.18),
          );
        }
      }
    }
    ctx.restore();
  }
}
