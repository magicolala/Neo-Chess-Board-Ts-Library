
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neo Chess Board â€“ Clock Demo</title>
    <style>
      :root {
        color-scheme: dark light;
      }

      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        color: #f8fafc;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 32px 16px;
      }

      .wrapper {
        max-width: 960px;
        width: 100%;
        display: grid;
        gap: 24px;
        grid-template-columns: minmax(0, 480px) minmax(0, 1fr);
        align-items: start;
      }

      .panel {
        background: rgba(15, 23, 42, 0.65);
        border-radius: 16px;
        padding: 24px;
        box-shadow: 0 18px 40px rgba(2, 6, 23, 0.45);
        backdrop-filter: blur(12px);
      }

      .board-shell {
        width: 100%;
        aspect-ratio: 1 / 1;
        position: relative;
        border-radius: 12px;
        overflow: hidden;
      }

      h1 {
        margin-top: 0;
        font-size: 28px;
      }

      h2 {
        margin-top: 0;
        font-size: 20px;
        color: #cbd5f5;
      }

      button {
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 10px 18px;
        font-size: 15px;
        background: rgba(148, 163, 184, 0.25);
        color: #f8fafc;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        background: rgba(148, 163, 184, 0.35);
      }

      button:active {
        transform: translateY(0);
      }

      .button-row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 24px;
      }

      .status {
        font-size: 15px;
        line-height: 1.6;
        background: rgba(15, 23, 42, 0.55);
        padding: 16px;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      .status strong {
        color: #38bdf8;
      }

      .time-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 0;
        border-bottom: 1px solid rgba(148, 163, 184, 0.15);
      }

      .time-row:last-of-type {
        border-bottom: none;
      }

      .time-row span {
        font-size: 18px;
        font-variant-numeric: tabular-nums;
      }

      @media (max-width: 900px) {
        .wrapper {
          grid-template-columns: minmax(0, 1fr);
        }
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <section class="panel">
        <h1>Clock-enabled chess board</h1>
        <p>
          This example enables the built-in clock system and uses the <code>ClockExtension</code> to render a floating overlay.
          Use the controls to start, pause, or tweak the timers.
        </p>
        <div class="board-shell">
          <div id="board"></div>
        </div>
      </section>
      <section class="panel">
        <h2>Controls</h2>
        <div class="button-row">
          <button id="start">Start</button>
          <button id="pause">Pause</button>
          <button id="reset">Reset</button>
          <button id="addWhite">+10s White</button>
          <button id="addBlack">+10s Black</button>
        </div>
        <div class="status">
          <div class="time-row">
            <strong>White</strong>
            <span id="whiteTime">05:00</span>
          </div>
          <div class="time-row">
            <strong>Black</strong>
            <span id="blackTime">05:00</span>
          </div>
          <p id="flagStatus" style="margin-top: 16px; color: #fbbf24"></p>
        </div>
      </section>
    </div>

    <script type="module">
      import { NeoChessBoard, createClockExtension } from '../index.js';

      const boardRoot = document.getElementById('board');
      const whiteDisplay = document.getElementById('whiteTime');
      const blackDisplay = document.getElementById('blackTime');
      const flagDisplay = document.getElementById('flagStatus');

      const startButton = document.getElementById('start');
      const pauseButton = document.getElementById('pause');
      const resetButton = document.getElementById('reset');
      const addWhiteButton = document.getElementById('addWhite');
      const addBlackButton = document.getElementById('addBlack');

      const formatTime = (ms) => {
        const totalSeconds = Math.max(0, Math.floor(ms / 1000));
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      };

      let overlayApi = null;

      const now =
        typeof performance !== 'undefined' && typeof performance.now === 'function'
          ? () => performance.now()
          : () => Date.now();
      const win = typeof window !== 'undefined' ? window : undefined;
      const requestFrame = win?.requestAnimationFrame?.bind(win) ?? ((cb) => setTimeout(() => cb(now()), 16));
      const cancelFrame =
        win?.cancelAnimationFrame?.bind(win) ?? ((handle) => clearTimeout(handle));

      const fallbackTicker = (() => {
        let handle = null;
        let running = false;
        let lastTimestamp = 0;

        const stop = () => {
          if (!running) {
            return;
          }
          running = false;
          if (handle !== null) {
            cancelFrame(handle);
            handle = null;
          }
          lastTimestamp = 0;
        };

        const tick = (timestamp) => {
          handle = null;

          if (overlayApi || !running) {
            stop();
            return;
          }

          const state = board.getClockState();
          if (!state || !state.isRunning || !state.active) {
            stop();
            return;
          }

          const previous = lastTimestamp || state.lastUpdatedAt || timestamp;
          const elapsed = Math.max(0, timestamp - previous);

          if (elapsed > 0) {
            const activeKey = state.active === 'w' ? 'white' : 'black';
            const side = state[activeKey];
            if (side) {
              const remaining = Math.max(0, side.remaining - elapsed);
              const update = { timestamp };
              const sideUpdate = { remaining };
              if (remaining === 0) {
                sideUpdate.isFlagged = true;
                update.running = false;
                update.paused = true;
                update.active = null;
              }
              if (activeKey === 'white') {
                update.white = sideUpdate;
              } else {
                update.black = sideUpdate;
              }
              board.updateClockState(update);
            }
          }

          if (!running) {
            stop();
            return;
          }

          lastTimestamp = timestamp;
          handle = requestFrame(tick);
        };

        const start = () => {
          if (overlayApi || running) {
            return;
          }
          running = true;
          lastTimestamp = 0;
          handle = requestFrame(tick);
        };

        const sync = (state) => {
          if (!running) {
            return;
          }
          if (!state || !state.isRunning || !state.active) {
            stop();
            return;
          }
          lastTimestamp = state.lastUpdatedAt ?? now();
        };

        return { start, stop, sync };
      })();

      const board = new NeoChessBoard(boardRoot, {
        soundEnabled: false,
        allowDragging: false,
        clock: {
          initial: { w: 300_000, b: 300_000 },
          increment: 2_000,
          active: 'w',
          paused: true,
        },
        extensions: [
          createClockExtension({
            onReady(api) {
              overlayApi = api;
              fallbackTicker.stop();
            },
          }),
        ],
      });

      const renderTimes = (state) => {
        if (!state) return;
        whiteDisplay.textContent = formatTime(state.white.remaining);
        blackDisplay.textContent = formatTime(state.black.remaining);
      };

      board.on('clockChange', (state) => {
        renderTimes(state);
        if (state.isRunning) {
          flagDisplay.textContent = '';
        }
        if (!overlayApi) {
          fallbackTicker.sync(state);
        }
      });

      board.on('clockFlag', ({ color }) => {
        flagDisplay.textContent = `${color === 'w' ? 'White' : 'Black'} flagged!`;
      });

      board.on('clockStart', () => {
        if (!overlayApi) {
          fallbackTicker.start();
        }
      });

      board.on('clockPause', () => {
        fallbackTicker.stop();
      });

      const startClock = () => {
        if (overlayApi) {
          overlayApi.startClock();
        } else {
          const state = board.getClockState();
          const activeColor = state?.active ?? board.getTurn();
          board.updateClockState({
            running: true,
            paused: false,
            active: activeColor,
            timestamp: now(),
          });
          fallbackTicker.start();
        }
      };

      startButton.addEventListener('click', startClock);

      pauseButton.addEventListener('click', () => {
        if (overlayApi) {
          overlayApi.pauseClock();
        } else {
          board.updateClockState({ running: false, paused: true, active: null, timestamp: null });
          fallbackTicker.stop();
        }
      });

      resetButton.addEventListener('click', () => {
        board.setClockConfig({
          initial: { w: 300_000, b: 300_000 },
          increment: 2_000,
          active: 'w',
          paused: true,
        });
        fallbackTicker.stop();
      });

      addWhiteButton.addEventListener('click', () => {
        const state = board.getClockState();
        if (overlayApi) {
          overlayApi.setTime('w', (state?.white.remaining ?? 0) + 10_000);
        } else {
          const remaining = (state?.white.remaining ?? 0) + 10_000;
          board.updateClockState({
            white: { remaining, isFlagged: false },
            timestamp: now(),
          });
        }
      });

      addBlackButton.addEventListener('click', () => {
        const state = board.getClockState();
        if (overlayApi) {
          overlayApi.setTime('b', (state?.black.remaining ?? 0) + 10_000);
        } else {
          const remaining = (state?.black.remaining ?? 0) + 10_000;
          board.updateClockState({
            black: { remaining, isFlagged: false },
            timestamp: now(),
          });
        }
      });

      renderTimes(board.getClockState());
    </script>
  </body>
</html>
